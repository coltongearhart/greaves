{
  "hash": "abc51c7c6c100b899981c7acc3e477cd",
  "result": {
    "markdown": "---\ntitle: Example 1\nauthor: Colton Gearhart\nformat: html\n---\n\n\n## Load packages\n\n\n::: {.cell warning.hidden='true' message.hidden='true'}\n\n```{.r .cell-code .hidden}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.3     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\nlibrary(ggpubr)\noptions(scipen = 999)\n\nlibrary(actuar) # for pareto() function\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\n\nAttaching package: 'actuar'\n\nThe following objects are masked from 'package:stats':\n\n    sd, var\n\nThe following object is masked from 'package:grDevices':\n\n    cm\n```\n\n\n:::\n:::\n\n\n## Set global plot options\n  \n\n::: {.cell warning.hidden='true' message.hidden='true'}\n\n```{.r .cell-code .hidden}\n# create default storytelling with data theme\ntheme_swd = theme_minimal() + theme(\n  # titles and captions\n  plot.title = element_text(size = rel(1.75), color = \"grey30\"),\n  plot.subtitle = element_text(size = rel(1.25), color = \"grey30\"),\n  plot.caption = element_text(hjust = 0, color = \"grey30\"),\n  # axes\n  axis.title.x = element_text(hjust = 0, color = \"grey30\"),\n  axis.title.y = element_text(hjust = 1, color = \"grey30\"),\n  axis.line = element_line(color = \"grey90\"),\n  axis.ticks = element_line(color = \"grey90\"),\n  # plot background and gridlines\n  panel.background = element_blank(),\n  panel.grid.major = element_line(linewidth = rel(0.5), color = \"grey90\"),\n  panel.grid.minor = element_line(linewidth = rel(0.5), color = \"grey90\"),\n  # legend\n  legend.title = element_text(color = \"grey30\"),\n  legend.text = element_text(color = \"grey30\")\n)\n\n# set global plot theme\ntheme_set(theme_swd)\n```\n:::\n\n::: {.cell warning.hidden='true' message.hidden='true'}\n\n```{.r .cell-code .hidden}\n#| label: norm\nplot(rnorm(10))\n```\n\n::: {.cell-output-display}\n![](example1_files/figure-html/norm-1.png){width=672}\n:::\n:::\n\n\n## Load required items\n\n\n::: {.cell warning.hidden='true' message.hidden='true'}\n\n```{.r .cell-code .hidden}\n# function to generate random data from conditional distributions\ngenerate_sample <- function(n = 10000, alpha = 5, beta = 100, start_x = 5, start_lambda = 1.5, seed = 0) {\n  \n  # create matrix\n  # -> NOTE -> matrices are much faster than dataframes\n  data_sample <- matrix(data = NA, nrow = n, ncol = 3, dimnames = list(NULL, c(\"iteration\", \"X\", \"lambda\")))\n  \n  # conditionally set random seed\n  if (seed > 0) set.seed(seed)\n  \n  # initialize counter and starting values\n  i = 1\n  data_sample[i, ] = c(i, start_x, start_lambda)\n  \n  # generate new data for x and lambda based on sequentially updated conditional distributions\n  while (i < n) {\n    \n    # record iteration\n    data_sample[i + 1, \"iteration\"] <- i + 1\n    \n    # sample from x | lambda\n    data_sample[i + 1, \"X\"] <- rexp(n = 1, rate = data_sample[i, \"lambda\"])\n    \n    # sample from lambda | x\n    data_sample[i + 1, \"lambda\"] <- rgamma(n = 1, shape = alpha + 1, rate = data_sample[i + 1, \"X\"] + beta)\n    \n    # increase counter\n    i <- i + 1\n  }\n  \n  return(data_sample)\n}\n\n# function to solve for density estimates\nestimate_density <- function(input_values = 1, given_values = 1, equation = 1) {\n  \n  # calculate density estimate\n  density_estimate <- equation(input_values, given_values) %>% colMeans\n}\n\n# function to perform calculations for x\ndensity_x_given_lambda <- function(X = 1, Lambda = 1) {\n  \n  # specify density equation\n  Lambda*exp(-Lambda*X)\n}\n\n# function to perform calculations for lambda\ndensity_lambda_given_x <- function(Lambda = 1, X = 1) {\n  \n  # specify density equation\n  (((X + beta)^(alpha + 1)) * (Lambda^alpha) * exp(-Lambda * (X + beta))) / gamma(alpha + 1)\n}\n```\n:::\n\n  \n## Generate data\n\n\n::: {.cell warning.hidden='true' message.hidden='true'}\n\n```{.r .cell-code .hidden}\n# initialize items\nn <- 1000\nalpha <- 5\nbeta <- 10\nstart_x <- 150\nstart_lambda <- 2\n\n# sample from conditional distributions\ndata_sample <- generate_sample(n = n, alpha = alpha, beta = beta, start_x = start_x, start_lambda = start_lambda, seed = 09222023)\n\n# create data for scatterplot\ndata_scatter <- data_sample %>% \n  data.frame %>% \n  filter(iteration > n - 100)\n\n# set number of burn-in iterations\nburn_in <- 100\n\n# remove burn-in iteration\ndata_sample2 <- data_sample %>% \n  data.frame %>% \n  filter(iteration > burn_in)\n```\n:::\n\n  \n## Check diagnostic plots and set burn-in iterations\n\n\n::: {.cell warning.hidden='true' message.hidden='true'}\n\n```{.r .cell-code .hidden}\n# check convergence with a trace plot\n# -> line plot of generated values across iterations\nggplot() +\n  geom_line(aes(x = iteration, y = X),\n            color = \"grey\", linewidth = 0.2,\n            data = data.frame(data_sample))\n```\n\n::: {.cell-output-display}\n![](example1_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n::: {#cell-fig-diag-scatter-plot-x .cell warning.hidden='true' message.hidden='true'}\n\n```{.r .cell-code .hidden}\n#| label: fig-diag-scatter-plot-x\n#| fig-cap: \"Scatterplot of generated sample values of X\"\n\n# create scatterplots of last iterations to visually check for randomness\nplot_scatter_x <- ggplot() +\n  geom_point(aes(x = iteration, y = X),\n             color = \"black\", fill = \"white\", shape = 21, size = 1, stroke = 0.5,\n             data = data_scatter) +\n  labs(title = \"Scatterplot of generated sampled values for X\", x = \"Iteration\", y = \"x\")\n```\n:::\n\n::: {#cell-fig-diag-scatter-plot-lambda .cell warning.hidden='true' message.hidden='true'}\n\n```{.r .cell-code .hidden}\n#| label: fig-diag-scatter-plot-lambda\n#| fig-cap: \"Scatterplot of generated sample values of λ\"\n\nplot_scatter_lambda <- ggplot() +\n  geom_point(aes(x = iteration, y = lambda),\n             color = \"black\", fill = \"white\", shape = 21, size = 1, stroke = 0.5,\n             data = data_scatter) +\n  labs(title = \"Scatterplot of generated sampled valuesd for λ\", x = \"Iteration\", y = expression(lambda))\n```\n:::\n\n\n## Create histograms of sampled values and include density curves\n\n\n::: {.cell warning.hidden='true' message.hidden='true'}\n\n```{.r .cell-code .hidden}\n# set maximum for x plot\nlimit_x <- quantile(data_sample2$X, 0.995)\n\n# in order to get the correct legend that I want...\n# -> have to trick ggplot by adding another aesthetic to the desired geom (just map the correct aesthetic to a string constant of what I want it to say)\n# -> then do a scale_<...>_manual(values = \"< desired color >\")\n# -> also in a labs statement, make the name of label of that aesthetic an empty string\n# cannot do this trick more than once with the same aesthetic\n# -> so if need the legend for multiple things, they must be mapped to different aesthetics\n# create histogram of x with marginal density curve overlaid\nplot_hist_x <- ggplot() +\n  geom_histogram(aes(x = X, y = after_stat(density), fill = \"Sampled values\"),\n                 bins = 40,  color = \"grey60\",\n                 data = data_sample2) +\n  stat_function(aes(x = x, color = \"Actual density\"),\n                # I have since added \"min = 0\"\n                fun = dpareto2, args = list(min = 0, shape = alpha, scale = beta),\n                data = data.frame(x = c(0, limit_x)),\n                n = 100000, size = 0.75) +\n  coord_cartesian(xlim = c(0, limit_x)) +\n  scale_fill_manual(values = \"white\") +\n  scale_color_manual(values = \"grey40\") +\n  labs(title = \"Histogram of generated sample values of X\", x = \"x\",\n       color = \"\", fill = \"\") +\n  theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\n# create histogram of lambda with marginal density curve overlaid\n# -> no limits were made for lmabda because there won't be huge outliers\nplot_hist_lambda <- ggplot() +\n  geom_histogram(aes(x = lambda, y = after_stat(density), fill = \"Sampled values\"),\n                 bins = 40, color = \"grey60\",\n                 data = data_sample2) +\n  stat_function(aes(x = x, color = \"Actual density\"),\n                fun = dgamma, args = list(shape = alpha, rate = beta),\n                data = data.frame(x = c(0, max(data_sample2$lambda))),\n                n = 100000, size = 0.75) +\n  scale_fill_manual(values = \"white\") +\n  scale_color_manual(values = \"grey40\") +\n  labs(title = \"Histogram of generated sample values of λ\", x = expression(lambda),\n       color = \"\", fill = \"\") +\n  theme(legend.position = \"bottom\")\n\n# display plots\nggarrange(plot_hist_x, plot_hist_lambda)\n```\n\n::: {.cell-output-display}\n![](example1_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n  \n## Solve for estimated densities\n  \n\n::: {.cell warning.hidden='true' message.hidden='true'}\n\n```{.r .cell-code .hidden}\n# set max for plot and calculate points to estimate density of x at (if is to make sure step isn't zero)\nstep_x <- ifelse(diff(range(data_sample2$X)) > 1,\n                 round((quantile(data_sample2$X, 0.995) - min(data_sample2$X))/40, 5) %>% as.numeric,\n                 0.01)\n# set maximum for lambda plot\nlimit_x = quantile(data_sample2$X, 0.995)\n\n# create matrices of data to be used for x\nvalues_x <- seq(0, limit_x, by = step_x)\nX1 <- matrix(data = , values_x, nrow = nrow(data_sample2), ncol = length(values_x), byrow = TRUE)\nLambda1 <- matrix(data = data_sample2$lambda, nrow = nrow(data_sample2), ncol = ncol(X1))\n\n# calculate density estimates for f(x)\ndata_estimated_x <- estimate_density(input_values = X1, given_values = Lambda1, equation = density_x_given_lambda) %>% \n  data.frame(x = values_x, f_x_hat = .)\n\n# set max for plot and  calculate points to estimate density of lambda at (if is to make sure step isn't zero)\nstep_lambda <- ifelse(diff(range(data_sample2$lambda)) > 1,\n                      round((quantile(data_sample2$lambda, 0.995) - min(data_sample2$lambda))/40, 5) %>% as.numeric,\n                      0.01)\n\n# create matrices of data to be used for lambda\nvalues_lambda <- seq(0, max(data_sample2$lambda), by = step_lambda)\nLambda2 <- matrix(data = , values_lambda, nrow = nrow(data_sample2), ncol = length(values_lambda), byrow = TRUE)\nX2 <- matrix(data = data_sample2$X, nrow = nrow(data_sample2), ncol = ncol(Lambda2))\n\n# calculate density estimates for f(lambda)\ndata_estimated_lambda <- estimate_density(input_values = Lambda2, given_values = X2, density_lambda_given_x) %>% \n  data.frame(lambda = values_lambda, f_lambda_hat = .)\n```\n:::\n\n\n## Create plots of estimated densities and actual densities\n\n\n::: {.cell warning.hidden='true' message.hidden='true'}\n\n```{.r .cell-code .hidden}\n# X plot\n# -> density estimates with marginal density curve overlaid\nplot_estimated_x <- ggplot() +\n  geom_point(aes(x = x, y = f_x_hat, fill = \"Estimated density\"),\n             color = \"black\", shape = 21, size = 2, stroke = 1,\n             data = data_estimated_x) +\n  stat_function(aes(x = x, color = \"Actual density\"),\n                fun = dpareto2, args = list(min = 0, shape = alpha, scale = beta),\n                data = data.frame(x = c(0, limit_x)),\n                n = 100000, size = 0.75) +\n  coord_cartesian(xlim = c(0, limit_x)) +\n  scale_fill_manual(values = \"white\") +\n  scale_color_manual(values = \"grey60\") +\n  labs(title = \"Estimated and actual density of X\", x = \"x\", y = expression(f(hat(x))),\n       color = \"\", fill = \"\") +\n  theme(legend.position = \"bottom\")\n\n# Lambda plot\n# -> density estimates with marginal density curve overlaid\nplot_estimated_lambda <- ggplot() +\n  geom_point(aes(x = lambda, y = f_lambda_hat, fill = \"Estimated density\"),\n             color = \"black\", shape = 21, size = 2, stroke = 1,\n             data = data_estimated_lambda) +\n  stat_function(aes(x = x, color = \"Actual density\"),\n                fun = dgamma, args = list(shape = alpha, rate = beta),\n                data = data.frame(x = c(0, max(data_sample2$lambda))),\n                n = 100000, size = 0.75) +\n  scale_fill_manual(values = \"white\") +\n  scale_color_manual(values = \"grey60\") +\n  labs(title = \"Estimated and actual density of  λ\", x = expression(lambda), y = expression(f(hat(lambda))),\n       color = \"\", fill = \"\") +\n  theme(legend.position = \"bottom\")\n\n# display plots\nggarrange(plot_estimated_x, plot_estimated_lambda)\n```\n\n::: {.cell-output-display}\n![](example1_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}